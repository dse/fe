#!/usr/bin/env bash
set -o errexit
set -o pipefail
set -o nounset
shopt -s lastpipe

declare -i print_command=0
declare -a user_exclude_files=()
declare -a user_include_files=()
declare -a user_exclude_dirs=()

main () {
    . "$(dirname "$0")/../share/fe/exclude-sets.sh"
    while (( $# )) ; do
        case "$1" in
            --print-command)
                print_command=1
                shift
                ;;
            --list-excludes)
                list_excludes
                exit 0
                ;;
            --exclude-binary|--exclude-binaries|--exclude-binary-files)
                exclude_files_grep () {
                    (( $# < 1 )) && return
                    exclude_files+=(\! -name "$1")
                }
                shift
                ;;
            -.html)
                for i in "${file_set__html[@]}" ; do
                    user_include_files+=(-o -name "${i}")
                done
                shift
                ;;
            -.css)
                for i in "${file_set__css[@]}" ; do
                    user_include_files+=(-o -name "${i}")
                done
                shift
                ;;
            -.js)
                for i in "${file_set__js[@]}" ; do
                    user_include_files+=(-o -name "${i}")
                done
                shift
                ;;
            +.html)
                for i in "${file_set__html[@]}" ; do
                    user_exclude_files+=(\! -name "${i}")
                done
                shift
                ;;
            +.css)
                for i in "${file_set__css[@]}" ; do
                    user_exclude_files+=(\! -name "${i}")
                done
                shift
                ;;
            +.js)
                for i in "${file_set__js[@]}" ; do
                    user_exclude_files+=(\! -name "${i}")
                done
                shift
                ;;
            --exclude=*)
                user_exclude_files+=(\! -name "${1#--exclude=}")
                shift
                ;;
            --exclude)
                if (( $# < 2 )) ; then
                    echo "option missing required argument -- ${1}"
                    exit 1
                fi
                user_exclude_files+=(\! -name "${2}")
                shift 2
                ;;
            --exclude-dir=*)
                user_exclude_dirs+=( \! \( -type d -name "${1#*=}" -prune \) )
                shift
                ;;
            --exclude-dir)
                if (( $# < 2 )) ; then
                    echo "option missing required argument -- ${1}"
                    exit 1
                fi
                user_exclude_dirs+=( \! \( -type d -name "${2}" -prune \) )
                shift 2
                ;;
            -.*)
                user_include_files+=(-o -name "*.${1#-.}")
                shift
                ;;
            --.*)               # --.html only adds .html, for example
                user_include_files+=(-o -name "*.${1#--.}")
                shift
                ;;
            +.*)
                user_exclude_files+=(\! -name "*.${1#+.}")
                shift
                ;;
            ++.*)
                user_exclude_files+=(\! -name "*.${1#++.}")
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    build_exclude_lists

    # parse command line arguments in the same way find does.

    declare -a find_options=()
    while (( $# )) ; do
        case "$1" in
            -P|-L|-H)
                find_options+=("$1")
                shift
                ;;
            -D|-O)
                if (( $# < 2 )) ; then
                    echo "option missing required argument - $1"
                    exit 1
                fi
                find_options+=("$1" "$2")
                shift 2
                ;;
            -D*|-O*)
                find_options+=("$1")
                shift
                ;;
            *)
                # ends options; starting point arguments follow
                break
                ;;
        esac
    done

    declare -a find_targets=()
    while (( $# )) ; do
        case "$1" in
            "!"|"("|-*)
                # ends starting points; find expression follows
                break
                ;;
            *)
                find_targets+=("$1")
                shift
                ;;
        esac
    done

    # File exclusions work a bit differently, so we don't need to do
    # this for them.
    if (( ${#user_include_files[@]} )) ; then
        user_include_files[0]='(' # replaces the first "-o"
        user_include_files+=(')')
    fi

    declare -a command=(
        find
        "${find_options[@]}"
        "${find_targets[@]}"
        "${exclude_dirs[@]}"
        "${user_exclude_dirs[@]}"
        "${user_include_files[@]}"
        "${user_exclude_files[@]}"
        "${exclude_files[@]}"
        "$@"
    )
    if (( print_command )) ; then
        echo "${command[@]@Q}"
    else
        exec "${command[@]}"
    fi
}

list_excludes () {
    local i
    echo "# directories"
    for (( i = 5; i <= ${#exclude_dirs[@]}; i += 8 )) ; do
        echo "${exclude_dirs[$i]}"
    done | if [[ -t 1 ]] ; then fmt ; else cat ; fi
    echo "# files"
    for (( i = 2; i <= ${#exclude_files[@]}; i += 3 )) ; do
        echo "${exclude_files[$i]}"
    done | if [[ -t 1 ]] ; then fmt ; else cat ; fi
}

declare -a exclude_dirs=()
declare -a exclude_files=()

# These functions may be redefined later.
exclude_dirs () {
    local i
    for i ; do
        exclude_dirs+=(   \! \( -type d -name "$i" -prune \)   )
    done
}
exclude_files_find_grep () {
    local i
    for i ; do
        exclude_files+=(   \! -name "$i"   )
    done
}
exclude_files_grep () {
    :
    # local i
    # for i ; do
    #     exclude_files+=(   \! -name "$1"   )
    # done
}

# This is executed after command line options are processed.
build_exclude_lists () {
    exclude_dirs=()
    exclude_files=()
    . "$(dirname "$0")/../share/fe/exclude-dirs.sh"
    . "$(dirname "$0")/../share/fe/exclude-files.sh"
}

main "$@"
